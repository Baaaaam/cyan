package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
	"text/tabwriter"
	"text/template"

	"code.google.com/p/go-uuid/uuid"

	_ "github.com/mxk/go-sqlite/sqlite3"
	"github.com/rwcarlsen/cyan/nuc"
	"github.com/rwcarlsen/cyan/post"
	"github.com/rwcarlsen/cyan/query"
)

var (
	help     = flag.Bool("h", false, "print this help message")
	custom   = flag.String("custom", "", "path to custom sql query spec file")
	dbname   = flag.String("db", "", "cyclus sqlite database to query")
	simidstr = flag.String("simid", "", "simulation id in hex (empty string defaults to first sim id in database")
)

var simid []byte

var command string

var db *sql.DB

var cmds = NewCmdSet()

// map[cmdname]sqltext
var customSql = map[string]string{}

func init() {
	cmds.Register("sims", "list all simulations in the database", doSims)
	cmds.Register("agents", "list all agents in the simulation", doAgents)
	cmds.Register("protos", "list all prototypes in the simulation", doProtos)
	cmds.Register("transcommods", "list transaction counts and quantities for each commodity", doTransCommods)
	cmds.Register("power", "print a time-series of power produced", doPower)
	cmds.Register("deployed", "print a time-series of a prototype's total active deployments", doDeployed)
	cmds.Register("built", "print a time-series of a new builds of a prototype", doBuilt)
	cmds.Register("inv", "print a time series of agents' inventory", doInv)
	cmds.Register("flow", "print a time series of material transacted between agents", doFlow)
	cmds.Register("flowgraph", "print a graphviz dot graph of resource arcs between facilities", doFlowGraph)
	cmds.Register("energy", "print thermal energy (J) generated by the simulation between 2 timesteps", doEnergy)
	cmds.Register("created", "show material created by one or more agents between specific timesteps", doCreated)
}

func initdb() {
	if *dbname == "" {
		log.Fatal("must specify database with -db flag")
	}

	var err error
	db, err = sql.Open("sqlite3", *dbname)
	fatalif(err)

	if *simidstr == "" {
		ids, err := query.SimIds(db)
		fatalif(err)
		simid = ids[0]
	} else {
		simid = uuid.Parse(*simidstr)
		if simid == nil {
			log.Fatalf("invalid simid '%s'", *simidstr)
		}
	}

	post.Process(db)
}

func main() {
	log.SetFlags(0)
	flag.Parse()

	if *help || flag.NArg() < 1 {
		fmt.Println("Usage: metric -db <cyclus-db> [opts] <command> [args...]")
		fmt.Println("Calculates metrics for cyclus simulation data in a sqlite database.")
		flag.PrintDefaults()
		fmt.Println("\nCommands:")
		for i := range cmds.Names {
			fmt.Printf("    %v: %v\n", cmds.Names[i], cmds.Helps[i])
		}
		return
	}

	if *custom != "" {
		data, err := ioutil.ReadFile(*custom)
		fatalif(err)
		fatalif(json.Unmarshal(data, &customSql))
	}

	// run command
	cmds.Execute(flag.Args())
}

func doCustom(cmd string, args ...interface{}) {
	s, ok := customSql[cmd]
	if !ok {
		log.Fatalf("Invalid command %v", cmd)
	}
	rows, err := db.Query(s, args...)
	fatalif(err)

	tw := tabwriter.NewWriter(os.Stdout, 4, 4, 1, ' ', 0)
	cols, err := rows.Columns()
	fatalif(err)
	for _, c := range cols {
		_, err := tw.Write([]byte(c + "\t"))
		fatalif(err)
	}
	_, err = tw.Write([]byte("\n"))
	fatalif(err)

	for rows.Next() {
		vs := make([]interface{}, len(cols))
		vals := make([]*sql.NullString, len(cols))
		for i := range vals {
			vals[i] = &sql.NullString{}
			vs[i] = vals[i]
		}
		err := rows.Scan(vs...)
		fatalif(err)

		for i, v := range vals {
			s := "NULL"
			if v.Valid {
				s = v.String
				if strings.Contains(strings.ToLower(cols[i]), "simid") {
					s = uuid.UUID(v.String).String()
				}
			}
			fmt.Fprintf(tw, "%v\t", s)
		}
		_, err = tw.Write([]byte("\n"))
		fatalif(err)
	}
	fatalif(rows.Err())
	fatalif(tw.Flush())
	return
}

func doSims(cmd string, args []string) {
	initdb()
	s := "SELECT i.SimId AS SimId,Duration,Handle,Decay FROM Info As i JOIN DecayMode AS d ON i.SimId=d.SimId WHERE i.SimId = ?"
	customSql[cmd] = s
	doCustom(cmd, simid)
}

func doAgents(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	proto := fs.String("proto", "", "filter by prototype (default is all prototypes)")
	fs.Usage = func() {
		log.Printf("Usage: %v", cmd)
		fs.PrintDefaults()
	}
	fs.Parse(args)
	initdb()

	iargs := []interface{}{simid}
	s := `SELECT AgentId,Kind,Prototype,ParentId,EnterTime,ExitTime,Lifetime FROM Agents
	      WHERE SimId = ?`
	if *proto != "" {
		s += ` AND Prototype = ?`
		iargs = append(iargs, *proto)
	}
	customSql[cmd] = s
	doCustom(cmd, iargs...)
}

func doPower(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	proto := fs.String("proto", "", "filter by prototype (default is all prototypes)")
	fs.Usage = func() {
		log.Printf("Usage: %v", cmd)
		fs.PrintDefaults()
	}
	fs.Parse(args)
	initdb()

	s := `SELECT tl.Time AS Time,TOTAL(Value) AS Power FROM timeseriespower AS p
		  LEFT JOIN timelist as tl ON tl.Time=p.Time AND tl.simid=p.simid
          LEFT JOIN agents as a on a.agentid=p.agentid AND a.simid=p.simid
          WHERE tl.simid=? {{.}}
          GROUP BY tl.Time`

	tmpl := template.Must(template.New("sql").Parse(s))
	var buf bytes.Buffer
	if *proto == "" {
		tmpl.Execute(&buf, "")
	} else {
		tmpl.Execute(&buf, " AND a.prototype='"+*proto+"' ")
	}
	customSql[cmd] = buf.String()
	doCustom(cmd, simid)
}

func doDeployed(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() { log.Printf("Usage: %v <prototype>", cmd); fs.PrintDefaults() }
	fs.Parse(args)
	if fs.NArg() < 1 {
		log.Fatal("must specify a prototype")
	}
	initdb()

	proto := fs.Arg(0)
	s := `SELECT tl.Time AS Time,IFNULL(n, 0) AS N_Deployed FROM timelist AS tl
		  LEFT JOIN (
			  SELECT tl.time AS time,COUNT(a.agentid) AS n FROM timelist AS tl
			  LEFT JOIN agents AS a ON a.entertime <= tl.time AND (a.exittime >= tl.time OR a.exittime ISNULL) AND a.simid=tl.simid
			  WHERE a.simid=? AND a.prototype=?
			  GROUP BY tl.time
		  ) AS sub ON sub.time=tl.time
		  WHERE tl.simid=?`
	customSql[cmd] = s
	doCustom(cmd, simid, proto, simid)
}

func doBuilt(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() { log.Printf("Usage: %v <prototype>", cmd); fs.PrintDefaults() }
	fs.Parse(args)
	if fs.NArg() < 1 {
		log.Fatal("must specify a prototype")
	}
	initdb()

	proto := fs.Arg(0)
	s := `SELECT tl.time AS Time,ifnull(sub.n, 0) AS N_Built FROM timelist AS tl
	      LEFT JOIN (
			  SELECT a.simid,tl.time AS time,COUNT(a.agentid) AS n FROM agents AS a
			  JOIN timelist AS tl ON tl.time=a.entertime
			  WHERE a.simid=? AND a.prototype=?
			  GROUP BY time
		  ) AS sub ON tl.time=sub.time AND tl.simid=sub.simid
		  WHERE tl.simid=?`

	customSql[cmd] = s
	doCustom(cmd, simid, proto, simid)
}

func doProtos(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() { log.Printf("Usage: %v", cmd); fs.PrintDefaults() }
	fs.Parse(args)
	initdb()

	s := "SELECT DISTINCT Prototype FROM Prototypes WHERE simid=?;"
	customSql[cmd] = s
	doCustom(cmd, simid)
}

func doTransCommods(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() { log.Printf("Usage: %v", cmd); fs.PrintDefaults() }
	fs.Parse(args)
	initdb()

	s := `SELECT Commodity,count(t.transactionid) AS N_Trans, TOTAL(r.quantity) AS Quantity
	      FROM transactions AS t
          JOIN Resources AS r ON r.ResourceId=t.ResourceId AND r.SimId=t.SimId
		  WHERE r.simid=?
          GROUP BY commodity;`
	customSql[cmd] = s
	doCustom(cmd, simid)
}

func doInv(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() {
		log.Printf("Usage: %v <prototype>", cmd)
		fs.PrintDefaults()
	}
	nucs := fs.String("nucs", "", "filter by comma separated `nuclide`s")
	fs.Parse(args)
	if fs.NArg() < 1 {
		log.Fatal("must specify a prototype")
	}
	initdb()

	proto := fs.Arg(0)
	s := `SELECT tl.Time AS Time,TOTAL(sub.qty) AS Quantity FROM timelist as tl
          LEFT JOIN (
			 SELECT tl.simid AS simid, tl.Time as time,TOTAL(inv.Quantity*c.MassFrac) AS qty
			 FROM timelist as tl
             JOIN inventories as inv on inv.starttime <= tl.time and inv.endtime > tl.time AND tl.simid=inv.simid
             JOIN agents as a on a.agentid=inv.agentid AND a.simid=inv.simid
             JOIN compositions as c on c.qualid=inv.qualid AND c.simid=inv.simid
             WHERE a.simid=? AND a.prototype=? {{.}}
             GROUP BY tl.Time
          ) AS sub ON sub.time=tl.time AND sub.simid=tl.simid
		  WHERE tl.simid=?
		  GROUP BY tl.Time;
          `

	tmpl := template.Must(template.New("sql").Parse(s))
	var buf bytes.Buffer
	tmpl.Execute(&buf, nuclidefilter(*nucs))
	fmt.Println(buf.String())
	customSql[cmd] = buf.String()
	doCustom(cmd, simid, proto, simid)
}

func doFlow(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() {
		log.Printf("Usage: %v <from-prototype> <to-prototype>", cmd)
		fs.PrintDefaults()
	}
	nucs := fs.String("nucs", "", "filter by comma separated `nuclide`s")
	fs.Parse(args)
	if fs.NArg() < 2 {
		log.Fatal("must specify a source and destination prototype")
	}
	initdb()

	from, to := fs.Arg(0), fs.Arg(1)
	s := `SELECT tl.Time,TOTAL(sub.qty) FROM timelist as tl
          LEFT JOIN (
             SELECT t.simid AS simid,t.time as time,SUM(c.massfrac*r.quantity) as qty
			 FROM transactions as t
             JOIN resources as r ON t.resourceid=r.resourceid AND r.simid=t.simid
             JOIN agents as send ON t.senderid=send.agentid AND send.simid=t.simid
             JOIN agents as recv ON t.receiverid=recv.agentid AND recv.simid=t.simid
             JOIN compositions as c ON c.qualid=r.qualid AND c.simid=r.simid
             WHERE send.prototype=? AND recv.prototype=? {{.}} AND t.simid=?
             GROUP BY t.time
          ) AS sub ON tl.time=sub.time AND tl.simid=sub.simid
		  WHERE tl.simid=?
		  GROUP BY tl.Time;
        `
	tmpl := template.Must(template.New("sql").Parse(s))
	var buf bytes.Buffer
	tmpl.Execute(&buf, nuclidefilter(*nucs))
	customSql[cmd] = buf.String()
	doCustom(cmd, from, to, simid, simid)
}

func doFlowGraph(cmd string, args []string) {
	fs := flag.NewFlagSet("flowgraph", flag.ExitOnError)
	fs.Usage = func() { log.Print("Usage: flowgraph"); fs.PrintDefaults() }
	proto := fs.Bool("proto", false, "aggregate nodes by prototype")
	t0 := fs.Int("t1", 0, "beginning of time interval (default is beginning of simulation)")
	t1 := fs.Int("t2", -1, "end of time interval (default if end of simulation)")
	fs.Parse(args)
	initdb()

	arcs, err := query.FlowGraph(db, simid, *t0, *t1, *proto)
	fatalif(err)

	fmt.Println("digraph ResourceFlows {")
	fmt.Println("    overlap = false;")
	fmt.Println("    nodesep=1.0;")
	fmt.Println("    edge [fontsize=9];")
	for _, arc := range arcs {
		fmt.Printf("    \"%v\" -> \"%v\" [label=\"%v\\n(%.3g kg)\"];\n", arc.Src, arc.Dst, arc.Commod, arc.Quantity)
	}
	fmt.Println("}")
}

func doCreated(cmd string, args []string) {
	fs := flag.NewFlagSet("created", flag.ExitOnError)
	fs.Usage = func() { log.Print("Usage: created [agent-id...]\nZero agents uses all agents"); fs.PrintDefaults() }
	t0 := fs.Int("t1", 0, "beginning of time interval (default is beginning of simulation)")
	t1 := fs.Int("t2", -1, "end of time interval (default if end of simulation)")
	fs.Parse(args)
	initdb()

	var agents []int

	for _, arg := range fs.Args() {
		id, err := strconv.Atoi(arg)
		fatalif(err)
		agents = append(agents, id)
	}

	m, err := query.MatCreated(db, simid, *t0, *t1, agents...)
	fatalif(err)
	fmt.Printf("%+v\n", m)
}

func doEnergy(cmd string, args []string) {
	fs := flag.NewFlagSet("energy", flag.ExitOnError)
	t0 := fs.Int("t1", 0, "beginning of time interval (default is beginning of simulation)")
	t1 := fs.Int("t2", -1, "end of time interval (default if end of simulation)")
	fs.Usage = func() {
		log.Print("Usage: energy")
		fs.PrintDefaults()
	}
	fs.Parse(args)
	initdb()

	e, err := query.EnergyProduced(db, simid, *t0, *t1)
	fatalif(err)
	fmt.Println(e)
}

func fatalif(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type CmdSet struct {
	funcs map[string]func(string, []string) // map[cmdname]func(cmdname, args)
	Names []string
	Helps []string
}

func NewCmdSet() *CmdSet {
	return &CmdSet{funcs: map[string]func(string, []string){}}
}

func (cs *CmdSet) Register(name, brief string, f func(string, []string)) {
	cs.Names = append(cs.Names, name)
	cs.Helps = append(cs.Helps, brief)
	cs.funcs[name] = f
}

func (cs *CmdSet) Execute(args []string) {
	cmd := args[0]
	f, ok := cs.funcs[cmd]
	if !ok {
		blankargs := make([]interface{}, len(args)-1)
		for i, arg := range args[1:] {
			blankargs[i] = arg
		}
		doCustom(cmd, blankargs...)
		return
	}
	f(cmd, args[1:])
}

func nuclidefilter(nucs string) string {
	if len(nucs) == 0 {
		return ""
	}

	nnucs := []nuc.Nuc{}
	for _, n := range strings.Split(nucs, ",") {
		nuc, err := nuc.Id(strings.TrimSpace(n))
		fatalif(err)
		nnucs = append(nnucs, nuc)
	}

	if len(nnucs) == 1 {
		return fmt.Sprintf(" AND c.nucid = %v", int(nnucs[0]))
	}

	filter := fmt.Sprintf(" AND c.nucid IN (%v", int(nnucs[0]))
	for _, nuc := range nnucs[1:] {
		filter += fmt.Sprintf(",%v", int(nuc))
	}
	return filter + ") "
}
